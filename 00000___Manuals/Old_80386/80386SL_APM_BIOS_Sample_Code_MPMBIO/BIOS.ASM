

;THIS MODULE RESIDES IN ATPOST MODULE OF STANDARD AT BIOS OF A 386 SL SYSTEM. 
;THE MODULE CONTAINS 386 SL SPECIFIC FEATURE SUPPORT.
;THIS MODULE WAS SPECIFICALLY DEVELOPED ON INTEL DEMO BOARD , ALSO
;CALLED DAVID BOARD WHICH SERVED OUR INTRO AND COMDEX NEEDS.
;DATED DEC 6 , 1990 .
;DEVELOPED AT  SMD1 APPS @ INTEL CORP. OF SANTA CLARA,CA.
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

;    INTEL CORPORATION  MAKES  NO WARRANTY  FOR THE  USE OF THIS

;    EXAMPLE  AND  ASSUMES  NO  RESPONSIBILITY  FOR  ANY  ERRORS

;    WHICH  MAY  APPEAR  IN  THIS  EXAMPLE  PROGRAM   NOR  DOES

;    IT MAKE  A  COMMITMENT  TO  UPDATE  THE  INFORMATION  THAT

;    ARE  CONTAINED  HEREIN.

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

;Update Information : Sep 12,1991.

;This file is unchanged from the MAY 5 version. This is because the
;present files still support only A-STEP 386SL.

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

;      < < < < < <  I M P O R T A N T    N O T I C E  > > > > > >      *

;THIS MODULE IS DESIGNED TO SERVE AS AN EXAMPLE FOR BIOS PROGRAMMERS   *
;WHO PROGRAM 386 SL BASED AT SYSTEM. IT MUST BE CONSIDERED AS AN       *
;EXAMPLE AND A PROGRAMMING IMPLEMENTATION RATHER THAN A LINE BY LINE   *
;CODE THAT HAS BEEN MAXIMISED FOR PROGRAMMING EFFICIENCY. THE PROGRAM  *
;HAS BEEN WRITTEN FOR CLARITY RATHER THAN PROGRAMMING ELEGANCE.	       *

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

;WE ADD THIS RESUME RESET PROCESS MODULE HERE AT THE POWER  UP ENTRY
;AND SYSTEM CONTROL RESET POINTS OF AN ATBIOS. THE CONTROL WILL BE USUALLY
;TRANSFERED TO THIS POINT AFTER A FAR JUMP AT RESET VECTOR 0FFFF:0 AND
;A REGULAR JUMP FROM THE SECOND JUMP POINT . (IN A STANDARD AT BIOS).

;THIS MODULE RECOGNISES WHETHER THE RESET EVENT WAS DUE TO A RESUME RESET
;OR IF IT IS DUE TO A RESUME RESET THEN IT ALLOWS THE MACHINE TO
;CONTINUE THE NORMAL BOOTING PROCEDURE OF A WARM OR COLD BOOT AS THE CASE
;MAY BE. IT CONTINUES NORMAL BOOTING RITUAL IF THE RESET
;IS NOT DUE TO A RESUME RESET . IF THE RESUME RESET HAS OCCURED
;NORMAL BOOTING PROCESS IS INTERRUPTED AND RESUME RESET PROCESSING IS
;DONE AND MACHINE ENTERS THE SPECIAL SM RAM OF THE 386 SL SUPER SET FOR
;FURTHER RESUME RESET PROCESSING.
;--------------------------------------------------------------------

	INCLUDE		REG_EQU.INC	;MY HOLY BOOK OF EQUATES.

;THE FILE  REG_EQU.INC HAS  ALL IT'S EQUATES THAT ARE 386 SL
;SPECIFIC. ALSO THE FILE HAS EQUATES FOR THE POWER MANAGEMENT MODULE
;PMI.ASM WHICH CONTROLS POWER MANAGEMENT. A SOURCE LISTING OF REG_EQU.INC
;IS PROVIDED IN THIS EXAMPLE PACKAGE..

;---------------------------------------------------------------------

	INCLUDE		PWRMN.MAC	;MY HANDY TOOL KIT.NEVER MEDDLE
                                        ;WITH IT.
;THE PWRMN.MAC IS A HANDY SET  OF MACROS FOR 386 SL SUPER SET. THIS 
;MACRO LIBRARY HAS ROUTINES THAT OPEN AND CLOSE SL SPACES..READ EXTENDED
;CMOS MEMORY..ETC . A SOURCE LISTING OF PWRMN.MAC IS PROVIDED IN THIS
;EXAMPLE PACKAGE.
;----------------------------------------------------------------------

;WE ADD RESUME PROCESSING CODE HERE TO PROCESS A RESUME RESET.

MY_PROCESS :

;CLOSE THE CPU POWER MODE REGISTER..
;NOTE : CLOSING OF CPUPWRMODE REGISTER MEANS RESETTING UNIT ENABLE AND
;ALSO MAKING CPUPWRMODE REGISTER INVISIBLE.WE USE THE CHANGE_REG MACRO
;OUT OF OUR TOOL-KIT . THE PARAMETERS TO BE SUPPLIED TO THE MACRO ARE
;<1> REGISTER NAME , <2>  BIT PATTERN TO <AND> (LOGICAL AND OPERATION)
; THE REGISTER BITS , <3> BIT PATTERN TO <OR> (LOGICAL OR OPERATION)
;IT MAY BE NOTED THAT IN THE SECOND PARAMETER WE ESSENTIALLY SPECIFY TO
;THE MACRO THE BITS TO BE RESET IN THE REGISTER UNDER CONSIDERATION 
;AND IN THE THIRD PARAMETER  WE SPECIFY THE BITS TO BE SET IN THE REGISTER
;UNDER CONSIDERATION.

		CHANGE_REG	CPUPWRMODE,0BFFCH,0100H

;CLOSE THE 82360SL INDEX SPACE...

		WRITE_82360SL	IDXLCK,01H

;---------------------------------------------------------------------
;NO DISTRUBANCE PLEASE.WE TURN OFF NMI.THIS STEP IS REDUNDANT AS THE CPU
;SYSTEM MODE ARCHITECTURE AUTOMATICALLY PREVENTS US FROM NMI'S
	CLI
	MOV     AL,NMIOFF
	OUT     NMIMSK,AL               ;Turn of NMI's
	CLD
;-----------------------------------------------------------------
;NOW WE NEED TO TEST , IF THE CPU RESET IS DUE TO A RESUME EVENT.IN OUR
;EXAMPLE DEMO SYSTEM (INTEL DAVID DEMO BOARD) WE ACCOMPLISH IT BY READING
;AND TESTING THE CMOS SHUTDOWN BYTE . WE WRITE THE SUSPEND SHUTDOWN BYTE
;IN THE SUSPEND EVENT PROCESSING ROUTINE , BEFORE PUTTING THE MACHINE TO
;SUSPEND STATE. IN THIS EXAMPLE THE SHUTDOWN BYTE VALUE	OF 0DH IS CHOSEN.

;---WE READ THE SUSPEND SHUTDOWN BYTE FROM CMOS RAM.

		MOV	AL,SHUTDOWN_SUS_ADD
		OR	AL,80H			;MASK OFF NMI.
		OUT	CMOSADD,AL
		JMP	$+2
		JMP	$+2
		JMP	$+2
		IN	AL,CMOSDATA		;GET CMOS SHUTDOWN BYTE.

		CMP	AL,SHUTDOWN_RESUME	;IS IT A RESUME RESET ?
		JZ	YES_RESUME		;PROCESS IT.

		JMP	NO_SUSPEND		;CONTINUE NORMAL BOOTING
                                                ;RITUAL.
;--------------------------------------------------------------------------
;WE START PROCESSING RESUME RESET. IN THE COURSE OF PROGRAM FLOW WE
;JUDICIOUSLY MAKE USE OF POST CODES , WHICH WILL EASE OUR DEBUGGING PROCESS.

YES_RESUME :

;WE PUT 97H TO POST CARD PORT 80H (ALSO CALLED MANUFACTURER'S PORT).
;POST CODE 97H MEANS ..."RESUME EVENT DETECTED AND PROCESSING STARTED.."

		MOV	AL,97H
		OUT	80H,AL
;----------------------------------------------------------
;STEP 1 : WE DISABLE SUSPEND_REFRESH FIRST.UNTIL WE DISABLE SUSPEND
;MEMORY REFRESH WE CAN NOT ACCESS RAM AND SO CAN NOT SET UP STACK , WE
;CAN NOT ENABLE SHADOWING ETC..
;WE REPEAT BUT REVERSE ALL THE STEPS OF OF INITIATING SUS_REF.
;WE BASICALLY KEEP BOTH IO AND  CPU 'S  IBU SPACE ENABLED .

		CLI
		UNLOCK_CPUPWRMODE
		OPEN_82360SL
		CLI

		MOV	AL,PM_SUS_REF			;POINT TO 0FFH INDEX
		OUT	CFGINDEX,AL			;OF 82360SL.

		CHANGE_REG  CPUPWRMODE,0BFF3H,000AH	;OPEN IBU.

		MOV	AL,00H				;RESET BIT 7 AND 1
		OUT	SUS_REF_ENBL,AL
;----------------------------------------------------------------------
;NOW WE HAVE DISABLED SUSPED REFRESH. WE NEED TO WAIT FOR REFRESH NORMAL
;BIT TO BE SET BY 386 SL CPU WHICH CONFIRMS AND GIVES US PERMISSION TO
;ACCESS ONBOARD MEMORY.REFRESH NORMAL BIT IS BIT 4 OF MCMODE REGISTER
;IN OMCU SPACE OF 386 SL.
;----------------------------------------------------------------------
		CHANGE_REG  CPUPWRMODE,0BFF3H,0002H	;OPEN OMCU

WAIT_REFRESH :
		JMP	$+2
		JMP	$+2
		JMP	$+2
		JMP	$+2
		JMP	$+2
		MOV	DX,MCMODE
		IN	AL,DX

		TEST	AL,10H		;IS REFRESH NORMAL YET ?
		JZ	WAIT_REFRESH

;------------------------------------------------------
;NOW WE START KEY BOARD INITIALIZATION..TI INITIALIZE THESE PERIPHERALS
;IT IS SAFE TO HAVE 8 WAIT STATES AS MANY OF THESE HAVE SOFTWARE DELAYS
;AND SILICON RECOVERY TIMES...
;INCREASE WAIT STATES TO 8 FOR KEY BOARD INIT...
;PROGRAM EBC1CR IN EBU AT 300H

	  CHANGE_REG  CPUPWRMODE,0BFFFH,000EH
	  CHANGE_REG  EBC1CR,0FFF0H,0008H	  

GET_OUT :
		CHANGE_REG  CPUPWRMODE,0BFFCH,0100H	;CLOSE CPUPWRMODE.

		WRITE_82360SL	0FAH,01H		;CLOSE 360SL SPACE.
;----------------------------------------------------------------------
;WE OUTPUT THE POST CODE OF 98H ONTO PORT 80H. CODE 98H SIGNIFIES
;THE MESSAGE "NORMAL REFRESH STARTED..."

		MOV	AL,98H
		OUT	80H,AL
;----------------------------------------------------------------------
;NOW THAT WE HAVE CRANKED UP REFRESH,WE CAN SET UP STACK AND WE CAN
;AFFORD TO USE CALLS IN OUR PROGRAM. IN THIS PARTICULAR EXAMPLE
;WE USE	LOW BIOS RAM LOCATIONS OF 0:4A2H TO 0:4A6H

;WARNING : STACK CAN NOT BE USED UNTIL YOU DISABLE THE SUS_REFRESH BUT
;NOW IT IS OK AS WE HAVE DISABLED SUSPEND REFRESH...

		XOR	AX,AX
		MOV	SS,AX
		NOP
		NOP
		MOV	SP,04A6H
;---------------------------------------------------------------------
;IN OUR EXAMPLE OF DAVID BOARD , IT MAY BE NOTED THAT THE KEY BOARD WOULD
;HAVE BEEN SWITCHED OFF DURING SUSPEND . SO WE NEED TO RE-INITIALISE THE
;KEY BOARD AGAIN.THIS CAN BE DONE , EITHER HERE IN THE BIOS SPACE OR
;INSIDE SM RAM. IN OUR EXAMPLE WE INITIALISE THE KEY BOARD IN THE BIOS
;AND OTHER PERIPHERALS INSIDE SM RAM.
;THE IMPORTANT POINT TO REMEMBER HERE IS THAT WE CAN NOT USE THE BIOS
;KEY BOARD INITIALISATION ROUTINES , BECAUSE THEY ARE USUALLY INTERRUPT
;DRIVEN FOR THEIR TIMING NEEDS IN A STANDARD AT BIOS AND AT THIS POINT
;WE ARE STILL IN SYSTEM MANAGEMENT MODE WHERE ALL THE INTERRUPTS ARE
;DISABLED. THERE ARE SEVERAL WAYS TO GET AROUND THIS PROBLEM.FOR EXAMPLE
;WE CAN POLL ON 8254  TIMER. BUT IN THIS EXAMPLE WE HAVE CHOSEN TO
;USE SOFTWARE WAIT LOOPS. THIS SIMPLIFIES THE CODE BUT MAKES IT MACHINE
;SPEED DEPENDANT.

;WE START KEY BOARD INITIALISATION...

RESET_AGAIN :

	IN	AL,60H
	JMP	$+2
	JMP	$+2
	CALL	NEAR PTR KEY_IB_EMPTY		;WAIT FOR COMMAND ACCEPTANCE.

;--NOW WE SOFT RESET THE 8042.
;WE BASICALLY WRITE  0AAH TO KEY BOARD CONTROLLER AND WAIT FOR ITS RESPONSE.
;WE GET AN ACKNOWLEDGEMENT OF 55H , IN CASE OF A SUCCESSFUL RESET.

	MOV	AL,0AAH
	OUT	64H,AL
	JMP	$+2
	JMP	$+2
	CALL	NEAR PTR KEY_IB_EMPTY
	JC	RESET_AGAIN
	IN	AL,60H

	CALL	NEAR PTR KEY_OB_FULL
	JC	RESET_AGAIN
	IN	AL,60H
	JMP	$+2
	JMP	$+2
	CMP	AL,55H
	JNZ	RESET_AGAIN

;WE GOT AN ACKNOWLEDGEMENT OF 55H , SO RESET WAS ACCEPTED.
;ENABLE THE KEY BOARD NOW..

	MOV	AL,0AEH
	OUT	64H,AL
	JMP	$+2
	JMP	$+2
	CALL	NEAR PTR KEY_OB_FULL
	IN	AL,60H
;SEND RESET TO THE KEY BOARD AND WAIT FOR 0AAH.
KB_RESET :
	CALL	NEAR PTR KEY_IB_EMPTY
	MOV	AL,KYBRST
	OUT	60H,AL
	JMP	$+2
	JMP	$+2
	CALL	NEAR PTR KEY_OB_FULL
	IN	AL,UPIIN
	JMP	$+2
	JMP	$+2
	MOV	AL,60H
	OUT	64H,AL
	JMP	$+2
	JMP	$+2
	CALL NEAR PTR KEY_IB_EMPTY
	MOV	AL,4DH
	OUT	60H,AL
;READ KEY BOARD ID.
	CALL	NEAR PTR KEY_IB_EMPTY
	JNC	OK_GO
NO_GO :
	JMP	KB_RESET
OK_GO :
	MOV	AL,KYBRID
	OUT	60H,AL
	JMP	$+2
	JMP	$+2
;MAKE SURE THAT RC PIN IS HIGH..

	MOV	AL,0D0H
	OUT	64H,AL
	JMP	$+2
	JMP	$+2
	CALL  NEAR PTR KEY_IB_EMPTY
	IN	AL,60H
	OR	AL,03H		;NO RC#..A20 STATUS IS RESTORED BY PM SW.
	MOV	BL,AL
	MOV	AL,0D1H
	OUT	64H,AL
	JMP	$+2
	JMP	$+2
	CALL	NEAR PTR KEY_IB_EMPTY
	MOV	AL,BL
	OUT	60H,AL

	CALL	NEAR PTR KEY_OB_FULL
	IN	AL,60H
;-----------------------------------------------------------------------
;NOW WE HAVE TO ENTER PM RAM FOR FURTHER PROCESSING . THIS WILL BE DONE
;AFTER CHECKING WHETHER PM RAM CONTENTS  ARE INTACT.THIS CAN BE DONE USING
;SEVERAL  MEMORY VALIDATION TECHNIQUES LIKE CHECK SUM CALCULATION ETC...
;IN OUR EXAMPLE IT IS DONE BY LOOKING FOR INTEL SIGNATURE , INSIDE SM RAM
;IF THE SIGNATURE IS FOUND TO BE INTACT , THEN IT IS ASSUMED THAT SM RAM
;IS NOT CORRUPTED AND IS SAFE TO ENTER.
;OUR INTEL SIGNATURE IS PRESENT IN SM RAM AT LOCATION 3000:8003H AND SHOULD
;READ "INTEL PM".
;------------------------------------------------------------------------
 		MOV	SI,8003H
		MOV	DI,OFFSET SIGNATURE
		MOV	AX,CS
		MOV	ES,AX
		MOV	AX,3000H
		MOV	DS,AX
		MOV	CX,09H
		CLD
		REPZ	CMPSB			;DOES THE SIGNATURE MATCH ?
		JZ	SIGN_OK			;SM RAM IS OK...
SMRAM_BAD :
;SIGNATURE CAN NOT BE READ. IT IS EITHER DUE TO SM RAM BEING CORRUPTED OR
;SM RAM NOT BEING ACCESSIBLE..WE PUT THE POST CODE 89H TO SIGNAL THIS.
		MOV	AL,SMRAM_BAD
		OUT	POST_PORT

		JMP	RESUME		;RETRY THE WHOLE OPERATION
;SO IF THE SM RAM IS REALLY BAD THE RE-TRY LOOP IS END-LESS AND POST CODES
;WILL RUN AS 97H,98H,89H,97H....ETC....
;---------------------------------------------------------------------------

SIGN_OK :
;WE ARE NOW ASSURED  OF SAFETY . SM RAM  SIGNATURE IS INTACT...SO WE PUT
;A POST CODE OUT TO SIGNIFY SM RAM OK...
		MOV	AL,SMRAM_OK
		OUT	POST_PORT
;---------------------------------------------------------------------------
;DECREASE WAIT STATES TO 1..KEY BOARD CTLR INIT IS DONE...SO WE SPPED UP
;THE EPROM ACCESS BY REDUCING WAIT STATES..BUT NOTE THAT SINCE SHADOWING
;IS ENABLED IN OUR SYSTEM ..EPROM ACCESSES COUNT ONLY DURING RESUME RESET..
;PROGRAM EBC1CR IN EBU AT 300H
;-------------------------------------------------------------------------
	  UNLOCK_CPUPWRMODE
	  CHANGE_REG  CPUPWRMODE,0BFFFH,000EH
	  CHANGE_REG  EBC1CR,0FFF0H,0001H	  
;-------------------------------------------------------
;SHADOW SUPPORT...WHEN OUR BIOS ENABLES SHADOWING IT WRITES TO 
;EXTENDED CMOS RAM...SO READ XCMOS TO FIND OUT IF SHADOWING IS ENABLED..
;PLEASE READ THE COMMENTS IN PMI.ASM (ABOU SHADOWING) TO FIND OUT WHY 
;THESE STEPS ARE NECESSARY IN AN SL SYSTEM DURING RESUME PROCESS...

		READ_XMOS	SYSTEM_STATUS_ADD
		TEST		AL,01H		;WAS SHADOWING ENABLED ??
		JZ		NO_SHADOW_RES

SHADOW_RES :

;NOW WE ENABLE SHADOWING...

		CHANGE_REG  CPUPWRMODE, 0BFF3H,000AH

		CHANGE_REG  OMSECR, 0000H, 05555H   ;MAKE F SEGMENT READ ONLY.
		CHANGE_REG  OMSFCR,0000H,05555H   ;MAKE F SEGMENT READ ONLY.

NO_SHADOW_RES :

;LOCK CPUPOWER MODE REGISTER NOW....

	  CHANGE_REG  CPUPWRMODE, 0BFFCH,0100H	  ;SET PHANTOM BIT.

;------------------------------------------
;AND CAN JUMP TO PM RAM ENTRY POINT.THIS PARTICULAR RELEASE OF SOFTWARE
;DOES NOT SUPPORT B-STEP TYPE OF SUSPEND AND RESUME..A MODIFICATION OF 
;THIS CODE IS NECESSARY TO MAKE IT WORK ON A B-STEP CHIP BECAUSE OF 
;ARCHITECTURAL DIFFERENCES BETWEEN THE TWO...

		DB	0EAH,00,80H,00,30H


SIGNATURE	DB	"INTEL PM",00H
;--------------------------------------------------------------------

NO_SUSPEND :
		JMP	NORMAL_BOOT_FLOW
;-------------------------------------------------------------------
;-----SUBROUTINES FOLLOW..
;--ROUTINE KEY_IB_EMPTY ..WAIT FOR INPUT BUFFER EMPTY FOLLOWS..
;A CARRY INDICATES AN ERROR.A SOFTWARE WATCH DOG TIMER IS PROVIDED TO
;AVOID SYSTEM HANGING IN THIS ROUTINE FOR-EVER.AS USUAL WE SET THE CARRY
;FLAG TO INDICATE AN ERROR .
;--------------------------------------------------------------------
KEY_IB_EMPTY	PROC	NEAR
	PUSH	AX
	PUSH	CX
	MOV	CX,0FFFFH
TRY_AGAIN1 :
	IN	AL,64H
	TEST	AL,02H
	JZ	EMPTY_BUFF
	DEC	CX
	JZ	NEVER_OCCR1
	JMP	TRY_AGAIN1
NEVER_OCCR1 :
	STC
	JMP	OUT_PROCESS
EMPTY_BUFF :
	CLC
OUT_PROCESS:
	POP	CX
	POP	AX
	RET
KEY_IB_EMPTY	ENDP
;---------------------------------------------------------------
;ROUTINE KEY_OB_FULL FOLLOWS..WAITS FOR OUTPUT BUFFER FULL.
;A CARRY INDICATES AN ERROR.A SOFTWARE WATCH DOG TIMER IS PROVIDED TO
;AVOID SYSTEM HANGING IN THIS ROUTINE FOR-EVER.AS PER OUR TRADITION WE SET
;THE CARRY FLAG TO INDICATE AN ERROR .
;-------------------------------------------------------------------
KEY_OB_FULL	PROC	NEAR
	PUSH	AX
	PUSH	CX
	MOV	CX,0FFFFH
TRY_AGAIN2 :
	IN	AL,64H
	TEST	AL,01H
	JNZ	FULL_BUFF
	DEC	CX
	JZ	NEVER_HAPPN
	JMP	TRY_AGAIN2
NEVER_HAPPN :
	STC
	JMP	OUT_PROCESS1
FULL_BUFF :
	CLC
OUT_PROCESS1 :
	POP	CX
	POP	AX
	RET
KEY_OB_FULL	ENDP
;---------------------------------------------------------
NORMAL_BOOT_FLOW :

;THE RESET HAS BEEN DETERMINED AT THIS POINT AS A NON-RESUME RESET.
;SO WE CONTINUE THE NORMAL BOOTING RITUAL OF A STANDARD AT BIOS .
;BUT THERE ARE A COUPLE OF ACTIONS THAT CAN BE TAKEN TO ASSURE A NORMAL
;AT BOOT OF THE SYSTEM. WE DISABLE THE POWER MANAGEMENT  WHICH MEANS
;THAT IN A WARM BOOT OR OTHER NORMAL AT RESET ACTIVITY WE ASSURE THAT
;THERE WILL BE NO INTERFERENCE DUE TO SYSTEM MANAGEMENT INTERRUPTS THAT
;OCCUR DUE TO  POWER MANAGEMENT ACTIVITY. BUT IT SHALL BE REMEMBERED THAT
;THIS LEAVES THE MACHINE WITHOUT POWER MANAGEMENT AT THE END OF THE BOOTING
;PROCESS. IN OUR EXAMPLE , WE GET AROUND IT BY RE-ENABLING IT IN OUR
;AUTOEXEC.BAT FILE.

		OPEN_82360SL  			;OPEN UP 386SL INDEX SPACE.
		CLI
		ALTER_82360SL	PM_REQ_CNTRL,7FH,00
                                                ;DISABLE POWER MANAGEMENT.

		WRITE_82360SL	IDXLCK,01H      ;CLOSE INDEX SPACE AGAIN.

;THE FOLLOWING LINES OF CODE IS HARDWARE SPECIFIC AND WAS WRITTEN TO GET
;A FASTER BOOTING TIME ON INTEL'S DAVID BOARD. DAVID USES PRIAREITEK
;HARD DRIVE , WHICH WE PUT TO ACTIVE MODE , SO THAT THE DISK RESPONDS
;IMMEDIATELY TO INT 19H BOOT CALL.

;-----HDD WAKE UP STUFF HERE...
	MOV	AL,0E1H
	MOV	DX,1F7H
	OUT	DX,AL

;------WAIT FOR RESPONSE....

	MOV	CX,0FFFFH

WAIT_DISK :

	DEC	CX
	JNZ	WAIT_DISK

;-------------------------------------------------
;NORMAL AT BOOTING PROCEDURE CONTINUES.....
;-------------------------------------------------
;NOW THE SOURCE CODE OF DAVID BOARD BIOS THAT DOES OUR SUPERSET
;INITIALIZATION FOLLOWS...

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

;   NOTE :  WHERE SHALL THE FOLLOWING INIT SEGMENT BE ATTACHED ??	*
;           THE ANSWER TO ABOVE QUESTION DEPENDS ON YOUR TYPE OF	*
;           BIOS..ALL  WE CAN SAY HERE IS THAT , THIS SEGMENT SHALL	*
;           BE EXECUTED BEFORE MEMORY SIZING AND TESTING BY YOUR BIOS..	*

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

;OPEN CPUPWR MODE REGISTER 

			UNLOCK_CPUPWRMODE

;WE DEFINE CACHE CONFIGURATION...(CCR SPACE) DAVID BOARD HAS ONLY 16 KBYTES
;WE USE IT IN 4 WAY SET ASSOCIATIVE MODE..

		CHANGE_REG	CPUPWRMODE,0BFF3H,0006H
		CHANGE_REG	CCR,0000H,0006H	
;------------------------------------------------------
;CHANGE WAIT STATES TO 8 INSTEAD OF 15. WE PROGRAM EBC1CR IN EBU AT 300H
;THIS IS DONE BECAUSE IN A STANDARD BIOS , THE PERIPHERALS ARE NOT 
;PROPERLY INITIALISED IF YOU DO NOT RUN THE INITIALIZATION PART WITH WAIT
;STATES..THIS DOES NOT AFFECT PERFORMANCE BECAUSE , WE BRING BACK THE
;WAIT STATES TO 1 AT THE END OF POST INIT AND ALSO BECAUSE WE ENABLE
;SHADOWING...
		CHANGE_REG  CPUPWRMODE,0BFFFH,000EH
		CHANGE_REG  EBC1CR,0FFF0H,0008H	  
;------------------------------------------
;WE DISABLE PARITY BECAUSE THE INTEL DAVID BOARD DOES NOT HAVE PARITY BITS.

		CHANGE_REG  CPUPWRMODE,0BFF3H,0002H
		CHANGE_REG  MCMODE,0FBH, 00              ;DISABLE PARITY.
;----------------------------------------------------------
;WE SELECT THE MEMEORY SIZE OF EACH BANK..IN DAVID BANK 0 HAS 2 MEG RAM.
;ALSO UPPER LIMIT IS 4 MEG. IN A STANDARD BIOS THIS MAY BE MADE PROGRAMMABLE
;BY A USER MENU CONFIGURATION UTILITY...

	SIZE_4MEG	EQU	0033H
	SIZE_2MEG	EQU	0013H

	MOV	BX,SIZE_4MEG                  ;MEM SIZE VALUE IN BX.

	CHANGE_REG  CPUPWRMODE,0BFF3H, 0002H    ;access to On-board memory
	CHANGE_REG  MCBS,00H, <BX>              ;change register
;--------------------------------------------------------------
;MEMORY LIMIT IS PROGRAMMED HERE..IN A STANDARD OEM BIOS , THIS IS 
;USUALLY DONE AFTER MEMORY AUTO-SIZING..

	MEM_LIMIT_2MEG		EQU	043H
	MEM_LIMIT_4MEG		EQU	047H

		MOV	BL,MEM_LIMIT_4MEG
		CHANGE_REG  CPUPWRMODE, 0BFF3H,000AH
		CHANGE_REGB OMLCR, 00H, <BL>      ; Lower Memory limit Reg.
;-------------------------------------------------------------
;TURN OFF WRITE POSTER..BECAUSE OF A-STEP BUG IN IBC..PLEASE SEE 
;ERRATA FOR DETAILS...THIS IS DONE BY SETTING A RESERVED BIT..

		MOV	BL,80H
		CHANGE_REG  CPUPWRMODE, 0BFF3H,000AH
		CHANGE_REGB 705H, 0FFH, <BL>      ; Lower Memory limit Reg.
;---------------------------------------------------------------
;PROGRAM THE OMDCR TO ALLOW ACCESS TO LOW MEMORY UPTO 640K BYTES..
;SL SUPERSET DEFAULT IS 512K UNLESS THIS REGISTER IS PROGRAMMED..

		MOV	BX,0000H
		CHANGE_REG  CPUPWRMODE, 0BFF3H,000AH
		CHANGE_REG  OMDCR, 0000H, <BX>   ; Lower Memory disabled Reg. to 640k
;----------------------------------------------------------------------
;MEMORY MODE SELECTION IS DONE BY PROGRAMMING MCDRAMMD..THE FASTEST MODE
;IS HIGH SPEED FAST PAGE MODE = 01..

		CHANGE_REG  CPUPWRMODE,0BFF3H, 0002H 
		CHANGE_REGB  MCDRAMMD,00H,01H          ;change register..
;--------------------------------------------------------------
;LOCK CPUPOWER MODE REGISTER NOW....

  CHANGE_REG  CPUPWRMODE, 0BFFCH,0100H	  ;SET PHANTOM BIT.

; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;NOW CONTINUE THE NORMAL AT BOOTING RITUAL FROM NOW ON...
;UNTIL YOU REACH INT 19H BOOT INITIATION POINT....
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;THE FOLLOWING CODE LINES ARE ADDED BEFORE INT 19H IS EXECUTED...
;
;   NOTE : THIS IS HOW IT IS ORGANISED ON A DAVID BOARD BIOS..BUT SIV'S
;          CAN CONFIGURE THE CODE LINES IN A WAY THAT IS SUITABLE TO 
;          THEIR SYSTEM...
; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

	  UNLOCK_CPUPWRMODE        ;Unlock the CPUPWRMODE registers

;WE ENABLE THE CACHE ON BOARD..

	CACHE_ENBL		EQU	80H

	MOV	BL,CACHE_ENBL
	CHANGE_REG  CPUPWRMODE, 0BFF3H,000AH
	CHANGE_REGB OMLCR, 0FFH, <BL>            ; OMLCR HAS CACHE ENBL BIT.
;-------------------------------------------------------------------------
;SHADOWING IS DONE HERE...
;SHADOWING SUPPORT FOR MAIN BIOS AT F000:0 TO F000:FFFFH.

	CHANGE_REG  CPUPWRMODE, 0BFF3H,000AH

	CHANGE_REG  OMSECR,0000H,0AAAAH	   ;MAKE F SEGMENT  WRITE ONLY. 
	CHANGE_REG  OMSFCR,0000H,0AAAAH	   ;MAKE F SEGMENT  WRITE ONLY.

;START COPYING THE ROM BIOS ONTO SHADOW RAM AREA...

	PUSH	DS
	PUSH	ES
	PUSH	SI
	PUSH	DI
;---------------
;COPY F SEGMENT ROM TO SHADOW RAM..
	MOV	AX,0F000H
	MOV	ES,AX
	MOV	DS,AX
	MOV	CX,0FFFFH
	XOR	SI,SI
	XOR	DI,DI
	CLD
	REP	MOVSB			;YES MOVE IT...MOVE IT..MOVE IT...
;----------------
	POP	DI
	POP	SI
	POP	ES
	POP	DS
;----------------------------
	CHANGE_REG  CPUPWRMODE, 0BFF3H,000AH
	CHANGE_REG  OMSECR, 0000H, 05555H	   ;MAKE F SEGMENT READ ONLY.
	CHANGE_REG  OMSFCR,0000H,05555H		   ;MAKE F SEGMENT READ ONLY.
;------------------------------------------------------------------
;SHADOWING DEMANDS CERTAIN SUPPORT FROM POWER MANAGEMENT SOFTWARE , SO
;THAT SUSPEND AND RESUME CAN WORK WITH SHADOW ENABLED..SO WE NEED TO
;RECOGNISE THE SHADOW INSIDE SM RAM DURING SUSPEND MODULE..THIS CAN BE
;DONE IN SEVERAL WAYS..WE CAN TRUST READING SHADOW REGISTERS TO FIND OUT
;IF THEY ARE READ ONLY FOR EXAMPLE..BUT IN THIS EXAMPLE WE DO IT BY
;SETTING A BIT IN THE EXTENDED CMOS RAM WHICH OUR 82360SL PROVIDES...
;THIS IS A GOOD USE FOR THAT EXTENDED CMOS RAM IS NOT IT ???

;WE WRITE PWRMN_STS BYTE , SO THAT WE CAN TAKE PROPER PWRMN ACTIONS.

		MOV	BL,CACHE_SHADOW_ENBL
		WRITE_XMOS	SYSTEM_STATUS_ADD,<BL>
;-------------------------------------------------------------------
;--CHANGE WAIT STATES TO 1 INSTEAD OF 15. WE PROGRAM EBC1CR IN EBU AT 300H

	  CHANGE_REG  CPUPWRMODE,0FFFFH,000EH
	  CHANGE_REG  EBC1CR,0FFF0H,0001H	  

;NOW WE LOCK CPUPWR MODE REGISTER.

	  CHANGE_REG  CPUPWRMODE, 0BFFCH,0100H	  ;SET PHANTOM BIT.
;----------------------------------------------------------------------
;CONTINUE INT 19H BOOT PROCESS....
;...........................




