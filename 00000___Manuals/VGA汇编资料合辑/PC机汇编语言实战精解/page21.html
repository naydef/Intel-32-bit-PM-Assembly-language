<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=gb2312">
<title>第2章 开始设计程序</title>
</head>

<body>
<style type="text/css">
body {
	background-color: #c0c0c0;
}

table {
	background-color: #c0c0c0;
	line-height: 24px;
}
</style>
<!导航条>
<p><a href="content1.html">目录</a> <a href="page20.html">上一页</a> <a href="page22.html">下一页</a> <a href="page27.html">下一章</a></p>
<table border=0 align="center" width=800 frame="box" rules="none">
<!标尺行>
<tr>
<td width=3%></td><td width=6%></td><td width=1%></td> <!左侧空白>
<td width=5%></td><td width=5%></td><td width=5%></td><td width=5%></td><td width=5%></td><td width=5%></td><td width=5%></td><td width=5%></td>
<td width=5%></td><td width=5%></td><td width=5%></td><td width=5%></td><td width=5%></td><td width=5%></td><td width=5%></td><td width=5%></td>
<td width=1%></td><td width=6%></td><td width=3%></td> <!右侧空白>
</tr>
<!页眉行>
<tr height=60 valign="bottom">
<td></td><td></td><td></td>
<td colspan=6><img src="icons/flag.gif"></td><td colspan=4></td><td colspan=6 align="right">第2章 开始设计程序</td> <!章节名>
<td></td><td>-21-</td><td></td> <!页码>
</tr>
<!页眉线>
<tr valign="top">
<td></td><td colspan=20><hr></td><td></td>
</tr>
<!正文>
<font face="宋体" lang="ZH-CN" size=3>
<tr height=20><td colspan=22></td></tr> <!顶部空白>

<tr>
<td></td><td></td> <!左边距>
<td colspan=3 align="center"></td>
<td colspan=15>
执　行：PUSH指令使"堆栈"中存入了寄存器或存储单元中数据的副本，POP指令会使"堆栈"中最顶端的数据出栈并进入给出的寄存器或存储单元中
</td>
<td></td><td></td> <!右边距>
</tr>

<tr>
<td></td><td></td> <!左边距>
<td colspan=18>
　　"堆栈"是内存中一段连续的存储单元，它主要用于临时存放数据。堆栈在内存中的位置可以是任何一段空闲存储单元，它的段地址由SS寄存器指示，而数据存放的位置由堆栈指针SP寄存器指示。那么堆栈段在应用上与一段存储段有何差别呢？
</td>
<td></td><td></td> <!右边距>
</tr>

<tr>
<td></td><td></td> <!左边距>
<td colspan=3 align="center"><img src="icons/attention.gif"></td>
<td colspan=15><font face="楷体_GB2312" lang="ZH-CN" size=3>
①  堆栈中保存的数据都是16位的，我们把16位的数据称为"字（WORD）"。8位数据无法用PUSH指令放入堆栈；<br>
②  其次，和程序不一样，堆栈的起始于内存"高地址"位置，这可以通过R命令观察到。进入DEBUG之后使用R命令查看各个寄存器的值，可以看到指令指针IP寄存器指向偏移0100H，而"堆栈指针"SP寄存器则指向0FFEEH。<br>
③  PUSH进栈的数据总是从高地址向低地址方向排列，每执行一次PUSH指令，SP寄存器就会自动减2，同时数据存入SP指向的位置。也就是说，只要不人为修改SP寄存器，那么SP将永远指向最后一个进入堆栈的数据；<br>
④  和PUSH指令相反，POP指令会把SP寄存器指向的数据取到指定寄存器中，同时SP会自动加2。所以，POP指令总是取出堆栈最后一个数据，即堆栈具有"后进先出"的性质。
</font></td>
<td></td><td></td> <!右边距>
</tr>

<tr>
<td></td><td></td> <!左边距>
<td colspan=8 align="center"><img src="figures/F2_7.gif"><br><font face="楷体_GB2312" lang="ZH-CN" size=3>图2-6  DEBUG状态下的堆栈设置</font></td>
<td></td><td></td>
<td colspan=8>
PROG1－B<br>
0B1D:0100 MOV CX,0800<br>
0B1D:0103 PUSH CX<br>
0B1D:0104 IN AL,61<br>
0B1D:0106 XOR AL,02<br>
0B1D:0108 OUT 61,AL<br>
0B1D:010A MOV CX,0500<br>
0B1D:010D LOOP 010D<br>
0B1D:010F POP CX<br>
0B1D:0110 LOOP 0103<br>
0B1D:0112 
</td>
<td></td><td></td> <!右边距>
</tr>

<tr>
<td></td><td></td> <!左边距>
<td colspan=18>
　　图2－6表示了进入DEBUG后代码和堆栈的位置。为了更好地说明堆栈的特性，我们用DEBUG编一小段程序：
</td>
<td></td><td></td> <!右边距>
</tr>

<tr>
<td></td><td></td> <!左边距>
<td></td><td></td> <!左边距>
<td colspan=6>
C:\ASM\>DEBUG[Enter]<br>
-a100[Enter]<br>
0B01:0100 mov ax,1234<br>
0B01:0103 mov bx,abcd<br>
0B01:0106 push ax<br>
0B01:0107 push bx<br>
0B01:0108 pop ax<br>
0B01:0109 pop bx<br>
0B01:010A [Enter]
</td>
<td></td>
<td colspan=9>输入这些内容</td>
<td></td><td></td> <!右边距>
</tr>

</font>
<!页脚线>
<tr valign="top">
<td></td><td colspan=20><hr></td><td></td>
</tr>
<!页脚>
<tr height=60 valign="top">
<td></td><td></td>
<td colspan=9><i>Copyright &copy; 2004-2005 <a href="mailto:webmaster@nucstorm.com">Chunk Lee</a></i></td>
<td colspan=9 align="right"><i><a href="http://www.nucstorm.com" target="_top">www.nucstorm.com</a></i></td>
<td></td><td></td>
</tr>
</table>
<!导航条>
<p align="right"><a href="content1.html">目录</a> <a href="page20.html">上一页</a> <a href="page22.html">下一页</a> <a href="page27.html">下一章</a></p>
</body>
</html>

