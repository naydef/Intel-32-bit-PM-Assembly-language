<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=gb2312">
<title>第9章 图形显示</title>
</head>

<body>
<style type="text/css">
body {
	background-color: #c0c0c0;
}

table {
	background-color: #c0c0c0;
	line-height: 24px;
}
</style>
<!导航条>
<p><a href="content1.html">目录</a> <a href="page262.html">上一页</a> <a href="page264.html">下一页</a> <a href="page269.html">下一章</a></p>
<table border=0 align="center" width=800 frame="box" rules="none">
<!标尺行>
<tr>
<td width=3%></td><td width=6%></td><td width=1%></td> <!左侧空白>
<td width=5%></td><td width=5%></td><td width=5%></td><td width=5%></td><td width=5%></td><td width=5%></td><td width=5%></td><td width=5%></td>
<td width=5%></td><td width=5%></td><td width=5%></td><td width=5%></td><td width=5%></td><td width=5%></td><td width=5%></td><td width=5%></td>
<td width=1%></td><td width=6%></td><td width=3%></td> <!右侧空白>
</tr>

<!页眉行>
<tr height=60 valign="bottom">
<td></td><td></td><td></td>
<td colspan=6><img src="icons/flag.gif"></td><td colspan=4></td><td colspan=6 align="right">第9章 图形显示</td> <!章节名>
<td></td><td>-263-</td><td></td> <!页码>
</tr>
<!页眉线>
<tr valign="top">
<td></td><td colspan=20><hr></td><td></td>
</tr>
<!正文>
<font face="宋体" lang="ZH-CN" size=3>
<tr height=20><td colspan=22></td></tr> <!顶部空白>

<tr>
<td></td><td></td> <!左边距>
<td colspan=18>
比较慢，不利于编制快速的图形程序。要想编制出高速的图形程序，我们还是需要直接对视频缓冲存储器进行操作，这就是本章第二节所要讨论的内容。
</td>
<td></td><td></td> <!右边距>
</tr>

<tr>
<td></td><td></td> <!左边距>
<td colspan=18><font face="黑体"><a name="92">9．2 直接写屏</a></font></td>
<td></td><td></td> <!右边距>
</tr>

<tr>
<td></td><td></td> <!左边距>
<td colspan=18>
　　在第六章里我们已经说过，屏幕上显示的内容与视频缓冲存储器内的数据具有单一的对应关系。在字符模式下屏幕上某个位置显示出的一个字符与视频缓存内特定地址存放的ASCII码与属性字节是相对应的。修改视频缓存中某个字节的内容，屏幕上相应位置的字符就会随之改变，或者变成其它字符，也可能改变了颜色。<br>
　　图形模式下也是这样，但在图形模式下这种对应关系"细化"了，不再是"字符--字节"之间的对应关系，而是变成"点--位"之间相对应。近一步说，是屏幕上的一个点与视频缓存中某个字节的某几个位相对应。<br>
　　为了搞清点与位之间的对应关系，我们还是要把DEBUG请出来。首先，我们先编个小程序将显示模式设置为CGA模式4:
</td>
<td></td><td></td> <!右边距>
</tr>

<tr>
<td></td><td></td> <!左边距>
<td colspan=12>
　　键入G命令后屏幕被置成图形模式，此时我们即可修改视频缓冲区了，还记得我们前面讨论过的"E"命令吗？<br>
　　在开始改变视频缓冲区之前，我们需要先将屏幕上乱糟糟的文字清除掉，免得影响观察。方法比较"土"，连续按住回车键不放，屏幕上的文字自然会"滚"出屏幕。而且此时光标也到了屏幕最低端。<br>
　　CGA模式4所需的显示缓存段地址同样是0B800H，这和文本模式相同。现在我们将显示缓存中第一个字节修改为"0AAH"：
</td>
<td colspan=6>
C:\ASM\>DEBUG[Enter]<br>
-a100[Enter]<br>
0E6A:0100 mov ax,0004<br>
0E6A:0103 int 10<br>
0E6A:0105 int 20<br>
0E6A:0107<br>
-g=100
</td>
<td></td><td></td> <!右边距>
</tr>

<tr>
<td></td><td></td> <!左边距>
<td colspan=18>
　　-EB800：0 AA[Enter]<br>
　　打一个空格之后注意观察屏幕左上角，看到有一道彩色的短横线吗？<br>
　　如果我们连续地修改显示缓存，就会看到这条短横线不断伸长，当然，我们无法使它最终延长到屏幕右侧，因为随着屏幕的滚动这条短线将被推到屏幕之外。看来若要在屏幕上画出较长的线来还要想别的方法。<br>
　　好在我们的老朋友"DEBUG"还是很体谅人的，它提供了一个专用于"填充内存块"的命令--F（Fill）。这个命令的使用方法如下：<br>
<font face="楷体_GB2312">
　　F<内存地址> <填充的字节数> <所填入的数据><br>
</font>
　　现在我们再次将屏幕清理干净，并使用"F"命令将显示缓冲区前50H个字节填成"0AAH"：<br>
　　-FB800:0 4F AA[Enter]<br>
　　于是屏幕最顶端出现了一条直线。当然，我们可以多填充一些字节，将刚才键入的命令做些变化，把命令中的4F变成50，看看有什么不同之处。<br>
　　-FB800:0 50 AA[Enter]<br>
　　区别还是有的：这条直线长了一些，而且长出的这一段在下面的一行最左端。由此看来显示缓冲区中每50H个字节对应着屏幕上的一个整行。<br>
　　前面我们已经讨论过，在CGA模式4下屏幕水平方向上可以显示320个点，而一行又恰好对应了显示缓冲区中80个字节，所以可以算出显示缓冲区内每一个字节对应了屏幕上的4个点。
</td>
<td></td><td></td> <!右边距>
</tr>

</font>

<!页脚线>
<tr valign="top">
<td></td><td colspan=20><hr></td><td></td>
</tr>
<!页脚>
<tr height=60 valign="top">
<td></td><td></td>
<td colspan=9><i>Copyright &copy; 2004-2005 <a href="mailto:webmaster@nucstorm.com">Chunk Lee</a></i></td>
<td colspan=9 align="right"><i><a href="http://www.nucstorm.com" target="_top">www.nucstorm.com</a></i></td>
<td></td><td></td>
</tr>
</table>
<!导航条>
<p align="right"><a href="content1.html">目录</a> <a href="page262.html">上一页</a> <a href="page264.html">下一页</a> <a href="page269.html">下一章</a></p>
</body>
</html>
