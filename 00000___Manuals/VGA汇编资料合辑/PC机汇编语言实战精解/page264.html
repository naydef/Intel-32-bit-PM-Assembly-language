<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=gb2312">
<title>第9章 图形显示</title>
</head>

<body>
<style type="text/css">
body {
	background-color: #c0c0c0;
}

table {
	background-color: #c0c0c0;
	line-height: 24px;
}
</style>
<!导航条>
<p><a href="content1.html">目录</a> <a href="page263.html">上一页</a> <a href="page265.html">下一页</a> <a href="page269.html">下一章</a></p>
<table 	border=0 align="center" width=800 frame="box" rules="none">
<!标尺行>
<tr>
<td width=3%></td><td width=6%></td><td width=1%></td>
<td width=5%></td><td width=5%></td><td width=5%></td><td width=5%></td><td width=5%></td><td width=5%></td><td width=5%></td><td width=5%></td>
<td width=5%></td><td width=5%></td><td width=5%></td><td width=5%></td><td width=5%></td><td width=5%></td><td width=5%></td><td width=5%></td>
<td width=1%></td><td width=6%></td><td width=3%></td>
</tr>
<!页眉行>
<tr height=60 valign="bottom">
<td></td><td>-264-</td><td></td> <!页码>
<td colspan=6>PC机汇编语言实战精解</td><td colspan=4></td><td colspan=6 align="right"><img src="icons/flag.gif"></td> <!书名>
<td></td><td></td><td></td> <!右侧空白>
</tr>
<!页眉线>
<tr valign="top">
<td></td><td colspan=20><hr></td><td></td>
</tr>
<!正文>
<font face="宋体" lang="ZH-CN" size=3>
<tr height=20><td colspan=22></td></tr> <!顶部空白>

<tr>
<td></td><td></td> <!左边距>
<td colspan=18>
　　再结合前面使用"E"命令时看到的现象，我们可以推断出这条直线最左端显示的点对应了显示缓存中0B800:0处的一个字节，而最右端的4个点对应了0B800:4F处的一个字节。这个规律可以用"E"命令加以验证。<br>
　　仔细观察长出的一小段直线，还可以看到这一小段直线与上面的直线之间是有间隙的，这又说明了什么问题呢？<br>
　　我们所能做出的唯一推断就是假如显示缓存中最前面的50H个字节对应屏幕上的第一行直线的话，那么紧接着的50H个字节不会对应屏幕上第二行直线，否则是不应该出现间隙的。<br>
　　如果我这个推断正确，那么屏幕上第二行直线究竟与显示缓存中哪些字节对应呢？带着这个问题，我们继续进行试验：<br>
　　首先清除屏幕，然后键入以下命令：<br>
　　-FB800:0 4AF FF[Enter]<br>
　　可以看到屏幕上出现了一组15条直线，每两条直线之间都有间隙。我们所以要画15条直线是因为屏幕上显示的内容要向上滚动，只画一两条直线难免在后面的操作中被推到屏幕之外去，这样我们就不知道屏幕上第一行直线在哪儿了。<br>
　　继续键入以下命令：<br>
　　-FBA00:0 4AF FF[Enter]<br>
　　这一下一切都清楚了，间隙中的直线都与显示缓存中0BA00段处的内容相对应。<br>
　　图形模式4的显示缓存组织有些特别，它是按"隔行扫描"方式组织的，说明确了，共16KB的显示缓存分成了两部分，前8KB存储器对应屏幕上的第0、2、4、6、・・・、198等偶数线，而后8KB对应第1、3、5、・・・、199等奇数线。<br>
　　每条线对应显示缓存中80个字节，每个字节对应屏幕上4个点。一个字节有8个bit，所以屏幕上每个点对应2个bit。最左面的点对应这个字节中的最高的2个bit，最右面的点对应最低的2个bit。2个bit共有4种组合--00、01、10、11，对应着4种颜色。<br>
　　以上就是编制直接写屏程序所需要了解的知识，根据上面所述我们现在来考虑一下下面这两种情况应如何处理：<br>
　　（1）在屏幕上（100，100）处画出一个白色点。假定现在使用第一组彩色。<br>
　　① 由于Y坐标为100，是偶数，所以确定含有此点的字节位于显示缓存的前8KB；<br>
　　② 由于每一行占用50H个字节，所以第100行的起始位置应该是50H （100/2）=0FA0H；把100除以2的含意很清楚，它虽然是屏幕上的第100线，实际上在所有偶数线中它是第50线。<br>
　　③ 由于每个字节可以表示屏幕上连续4个点，所以Y坐标=100处的点应该位于这一行内偏移量为100/4=25的那个字节内，总的偏移量是0FA0H+19H=0FB9H；<br>
　　④ 把Y坐标除以4后取余数，由于余数恰好为0，所以这个点将由字节中的最高两个bit表示，又因为我们要画一个白色点，所以写入显示缓冲区的一字节数据应该是11000000B；<br>
　　结论：画出此点的方法是向内存0B800H:0FB9H处写入0C0H即可。<br>
　　（2）在屏幕上（53，67）处画一个品红色点。假定使用第一组彩色。<br>
　　① 由于Y坐标是奇数，所以含有此点的内存单元位于显示缓冲区的后8KB中；<br>
　　② 第67线的起始位置等于50H*67/2=0A50；<br>
　　③ 含有第53点的一个字节在这一行内的偏移量为53/4=0DH；总的偏移量为
</td>
<td></td><td></td> <!右边距>
</tr>

</font>

<!页脚线>
<tr valign="top">
<td></td><td colspan=20><hr></td><td></td>
</tr>
<!页脚>
<tr height=60 valign="top">
<td></td><td></td>
<td colspan=9><i>Copyright &copy; 2004-2005 <a href="mailto:webmaster@nucstorm.com">Chunk Lee</a></i></td>
<td colspan=9 align="right"><i><a href="http://www.nucstorm.com" target="_top">www.nucstorm.com</a></i></td>
<td></td><td></td>
</tr>
</table>
<!导航条>
<p align="right"><a href="content1.html">目录</a> <a href="page263.html">上一页</a> <a href="page265.html">下一页</a> <a href="page269.html">下一章</a></p>
</body>
</html>
