<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=gb2312">
<title>第3章 中断调用与子程序</title>
</head>

<body>
<style type="text/css">
body {
	background-color: #c0c0c0;
}

table {
	background-color: #c0c0c0;
	line-height: 24px;
}
</style>
<!导航条>
<p><a href="content1.html">目录</a> <a href="page40.html">上一页</a> <a href="page42.html">下一页</a> <a href="page45.html">下一章</a></p>
<table border=0 align="center" width=800 frame="box" rules="none">
<!标尺行>
<tr>
<td width=3%></td><td width=6%></td><td width=1%></td> <!左侧空白>
<td width=5%></td><td width=5%></td><td width=5%></td><td width=5%></td><td width=5%></td><td width=5%></td><td width=5%></td><td width=5%></td>
<td width=5%></td><td width=5%></td><td width=5%></td><td width=5%></td><td width=5%></td><td width=5%></td><td width=5%></td><td width=5%></td>
<td width=1%></td><td width=6%></td><td width=3%></td> <!右侧空白>
</tr>

<!页眉行>
<tr height=60 valign="bottom">
<td></td><td></td><td></td>
<td colspan=6><img src="icons/flag.gif"></td><td colspan=4></td><td colspan=6 align="right">第3章 中断调用与子程序</td> <!章节名>
<td></td><td>-41-</td><td></td> <!页码>
</tr>
<!页眉线>
<tr valign="top">
<td></td><td colspan=20><hr></td><td></td>
</tr>

<!正文>
<font face="宋体" lang="ZH-CN" size=3>
<tr height=20><td colspan=22></td></tr> <!顶部空白>

<tr>
<td></td><td></td> <!左边距>
<td colspan=18>
　　"MicroSoft"还是很重视这个对手的，因此在DOS中特意保留了CP/M的特征，以便于和CP/M－86兼容且易于将那些为CP/M编写的应用程序移植到DOS中。由此便有了这个"CD 20"，也就有了前面的"RET之谜"。<br>
　　讲到此我们对CALL/RET可以说已经有较完整的印象了。不过以上对这两条指令的讨论还是很粗浅的，这里面还有更多的滋味我们还没有尝到，还需要更细致地加以咀嚼。
</td>
<td></td><td></td> <!右边距>
</tr>

<tr>
<td></td><td></td> <!左边距>
<td colspan=18>
<font face="黑体" lang="ZH-CN"><a name="34">3．4 细致的咀嚼</a></font>
</td>
<td></td><td></td> <!右边距>
</tr>

<tr>
<td></td><td></td> <!左边距>
<td colspan=18>
　　上一节给出了CALL指令的一种用法，这是很不全面的。这一节我们将"品尝"几个新程序，同时要"吃"出CALL指令更多的营养。请看下面的这个程序：
</td>
<td></td><td></td> <!右边距>
</tr>

<tr>
<td></td><td></td> <!左边距>
<td></td>
<td colspan=8>PROG4-B</td><td colspan=8></td>
<td></td><td></td><!右边距>
</tr>

<tr>
<td></td><td></td> <!左边距>
<td></td>
<td colspan=8>-u100 12a[Enter]</td><td colspan=8></td>
<td></td><td></td><!右边距>
</tr>

<tr>
<td></td><td></td> <!左边距>
<td></td>
<td colspan=5>
0A3E:0100 B401<br>
0A3E:0102 CD21<br>
0A3E:0104 9A1F01220A<br>
0A3E:0109 3C1B<br>
0A3E:010B 75F3<br>
0A3E:010D CD20<br>
0A3E:010F 50<br>
0A3E:0110 88C6<br>
0A3E:0112 B780<br>
0A3E:0114 B90800<br>
0A3E:0117 88F3<br>
0A3E:0119 B230<br>
0A3E:011B 20FB<br>
0A3E:011D 7402<br>
0A3E:011F B231<br>
0A3E:0121 B402<br>
0A3E:0123 CD21<br>
0A3E:0125 D0EF<br>
0A3E:0127 E2EE<br>
0A3E:0129 58<br>
0A3E:012A CB
</td>

<td colspan=2>
MOV<br>
INT<br>
CALL<br>
CMP<br>
JNZ<br>
INT<br>
PUSH<br>
MOV<br>
MOV<br>
MOV<br>
MOV<br>
MOV<br>
AND<br>
JZ<br>
MOV<br>
MOV<br>
INT<br>
SHR<br>
LOOP<br>
POP<br>
RETF
</td>

<td colspan=2>
AH,01<br>
21<br>
0A3D:011F<br>
AL,1B<br>
0100<br>
20<br>
AX<br>
DH,AL<br>
BH,80<br>
CX,0008<br>
BL,DH<br>
DL,30<br>
BL,BH<br>
0121<br>
DL,31<br>
AH,02<br>
21<br>
BH,1<br>
0117<br>
AX<br>
<br>
</td>

<td colspan=8>
；选择DOS API的01功能<br>
；调用21H中断等待键盘输入<br>
；调用0A3D：011F处的子程序<br>
；输入的字符是"ESC"吗？<br>
；不是"ESC"则转至0100H<br>
；是"ESC"则结束程序<br>
；子程序开始，保存AX寄存器副本<br>
；输入字符的ASCII码置入DH寄存器<br>
；BH寄存器置入"掩膜"10000000B<br>
；处理8个数位<br>
；BL寄存器置入输入字符的ASCII码<br>
；DL寄存器置入字符0的ASCII码30H<br>
；将ASCII码与"掩模"相与<br>
；若结果为0，转至0121显示字符0<br>
；将字符1的ASCII码置入DL寄存器<br>
；选择DOS API的02H功能<br>
；显示DL寄存器中的字符<br>
；"掩模"向右移动一位<br>
；循环至0117处理Bit6位<br>
；恢复AX寄存器的原值<br>
；返回主程序
</td>

<td></td><td></td> <!右边距>
</tr>

<tr>
<td></td><td></td> <!左边距>
<td colspan=18>
　　我们以"U"的形式给出这个程序，此程序没有存盘的必要。不过请大家务必注意不要原封不动地打入CALL指令后给出的"段:偏移"逻辑地址，因为在不同的机器上需要输入不同的段地址。段地址计算很简单，只需将CS中的实际段地址减1即可。输入程序后我们用"P"命令跟踪：
</td>
<td></td><td></td> <!右边距>
</tr>
</font>

<!页脚线>
<tr valign="top">
<td></td><td colspan=20><hr></td><td></td>
</tr>
<!页脚>
<tr height=60 valign="top">
<td></td><td></td>
<td colspan=9><i>Copyright &copy; 2004-2005 <a href="mailto:webmaster@nucstorm.com">Chunk Lee</a></i></td>
<td colspan=9 align="right"><i><a href="http://www.nucstorm.com" target="_top">www.nucstorm.com</a></i></td>
<td></td><td></td>
</tr>
</table>
<!导航条>
<p align="right"><a href="content1.html">目录</a> <a href="page40.html">上一页</a> <a href="page42.html">下一页</a> <a href="page45.html">下一章</a></p>
</body>
</html>

